
# cc/conf

CPP=
CAS=

AS=
LINK="\$(CC)"

CFLAGS=
ASFLAGS=
LDFLAGS=
LFLAGS=
YFLAGS=

INC=
LDLIBS=

nm_pic_opt=
nm_cpu_opt=

nm_symbol_opt=
nm_optimize_opt=
nm_warn_opt=
nm_error_opt=
nm_verbose_opt=
nm_debug_opt=
nm_shared_opt=

nm_stage_pre=
nm_stage_chk=
nm_stage_asm=
nm_stage_c=

nm_p=":"

obj_out="-o "
bin_out="-o "
cpp_out="-o "
asm_out="-o "

obj_ext=".o"
bin_ext=
cpp_ext=".i"
asm_ext=".s"
lib_ext=".so"


. ${NM_HOME}auto/cc/name

have=`echo CC_$CC_NAME | tr '[:lower:]' '[:upper:]'` . ${NM_HOME}auto/have_headers


case $CC_NAME in
  gcc)
    . ${NM_HOME}auto/cc/gcc
  ;;

  clang)
    . ${NM_HOME}auto/cc/clang
  ;;

  msvc*)
    . ${NM_HOME}auto/cc/msvc
	;;
esac


CC_TEST_LD_OPT="$NM_LD_OPT"

# symbol option
if [ "$NM_SYMBOL" = "YES" ]; then
	CFLAGS=${CFLAGS:+$CFLAGS }$nm_symbol_opt
fi


# optimize option
case "$NM_OPTIMIZE" in
	YES)
		CFLAGS=${CFLAGS:+$CFLAGS }$nm_optimize_opt
		;;
	NO)
		;;
	*)
		CFLAGS=${CFLAGS:+$CFLAGS }$NM_OPTIMIZE
		;;
esac


# warn option
case "$NM_WARN" in
	YES)
		CFLAGS=${CFLAGS:+$CFLAGS }$nm_warn_opt
		;;
	NO)
		;;
	*)
		CFLAGS=${CFLAGS:+$CFLAGS }$NM_WARN
		;;
esac

# error option: stop on warnings
if [ "$NM_ERROR" = "YES" ]; then
	CFLAGS=${CFLAGS:+$CFLAGS }$nm_error_opt
fi

# debug option
if [ "$NM_DEBUG" = "NO" ]; then
	nm_debug_opt='-DNDEBUG=1'
	CFLAGS=${CFLAGS:+$CFLAGS }$nm_debug_opt
fi

# verbose option
if [ "$NM_VERBOSE" = "YES" ]; then
	CFLAGS=${CFLAGS:+$CFLAGS }$nm_verbose_opt
fi

CFLAGS=${CFLAGS:+$CFLAGS }$nm_cpu_opt
LDFLAGS=${LDFLAGS}

nm_shared_opt=${nm_shared_opt:+$nm_shared_opt }$nm_pic_opt


# independent features checking


nm_feature="endian"
nm_feature_name="nm_have_little_endian"
nm_feature_run=value
nm_feature_incs="#include <stdio.h>"
nm_feature_path=
nm_feature_libs=
nm_feature_test='int i=0x11223344;
                 char *p = (char *)&i;
            		 int le = (0x44 == *p);
                 printf("%d", le);'
. ${NM_HOME}auto/feature


nm_feature="c11 type-generic expression"
nm_feature_name="nm_have_generic_keyword"
nm_feature_run=no
nm_feature_incs="#include <math.h>
#define cbrt(x) _Generic((x), long double: cbrtl, \
                              default: cbrt, \
                              float: cbrtf)(x)"
nm_feature_path=
nm_feature_libs=
nm_feature_test="long double x=cbrt(3.1415L);double y=cbrt(2.718);"
. ${NM_HOME}auto/feature

nm_feature="c99 variadic macro"
nm_feature_name="nm_have_variadic_macro"
nm_feature_run=yes
nm_feature_incs="#include <stdio.h>
#define var(dummy, ...)  sprintf(__VA_ARGS__)"
nm_feature_path=
nm_feature_libs=
nm_feature_test="char  buf[30]; buf[0] = '0';
               	 var(0, buf, \"%d\", 1);
        			   if (buf[0] != '1') return 1"
. ${NM_HOME}auto/feature


nm_feature="c99 stdint.h header file"
nm_feature_name="nm_have_stdint_h"
nm_feature_run=no
nm_feature_incs="#include <stdint.h>"
nm_feature_path=
nm_feature_libs=
nm_feature_test="int8_t c='X';"
. ${NM_HOME}auto/feature


if test -n "$NM_LD_OPT"; then
  nm_feature=--with-ld-opt=\"$NM_LD_OPT\"
  nm_feature_name=
  nm_feature_run=no
  nm_feature_incs=
  nm_feature_path=
  nm_feature_libs=
  nm_feature_test=
  . ${NM_HOME}auto/feature

  if [ $nm_found = no ]; then
    echo $0: error: the invalid value in --with-ld-opt=\"$NM_LD_OPT\"
    echo
    exit 1
  fi
fi


# gcc features checking


if [ "$CC_NAME" = "gcc" ]; then

  nm_feature="-std=c99 switch"
  nm_feature_name=nm_have_${CC_NAME}_std_c99
  nm_feature_run=no
  nm_feature_incs=
  nm_feature_path=
	nm_feature_flags=-std=c99
  nm_feature_libs=
  nm_feature_test="for (int i=0; i<3; i++) {}"
  . ${NM_HOME}auto/feature

  if [ $nm_found = yes ]; then
		CFLAGS=${CFLAGS:+$CFLAGS }"$nm_feature_flags"
  fi

  nm_feature="-Wl,-E|--export-dynamic"
  nm_feature_name=
  nm_feature_run=no
  nm_feature_incs=
  nm_feature_path=
  nm_feature_libs=-Wl,-E
  nm_feature_test=
  . ${NM_HOME}auto/feature

  if [ $nm_found = yes ]; then
    LDFLAGS=${LDFLAGS:+$LDFLAGS }"-Wl,-E"
  fi

  nm_feature="gcc builtin atomic operations"
  nm_feature_name=NM_HAVE_GCC_ATOMIC
  nm_feature_run=yes
  nm_feature_incs=
  nm_feature_path=
  nm_feature_libs=
  nm_feature_test="long  n = 0;
                 if (!__sync_bool_compare_and_swap(&n, 0, 1))
                   return 1;
                 if (__sync_fetch_and_add(&n, 1) != 1)
                   return 1;
                 if (n != 2)
                   return 1;
                 __sync_synchronize();"
  . ${NM_HOME}auto/feature

  nm_feature="gcc builtin 64 bit byteswap"
  nm_feature_name="NM_HAVE_GCC_BSWAP64"
  nm_feature_run=no
  nm_feature_incs=
  nm_feature_path=
  nm_feature_libs=
  nm_feature_test="if (__builtin_bswap64(0)) return 1"
  . ${NM_HOME}auto/feature

fi


